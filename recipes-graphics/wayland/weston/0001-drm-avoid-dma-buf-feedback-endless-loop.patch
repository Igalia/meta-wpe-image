From f971f68a94d0a8cf11be6312373ef5e8eab55f15 Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Tue, 24 Sep 2024 11:23:50 -0300
Subject: [PATCH] drm: avoid dma-buf feedback endless loop

Currently we have the following situation: we add a scanout tranche
because if the client re-allocates with another format/modifier, the
chances of being placed in a DRM/KMS plane is higher.

But then we run out of overlay planes. So we remove the scanout tranche,
because the format/modifier available in the renderer tranche are
optimal for rendering.

Now Weston detects again that the format/modifier is what may be
avoiding the view being place in a plane, re-adding the scanout tranche.
And we have an endless loop.

To avoid this, let's accumulate the reasons why placing the view in a
place failed. So if we detect that we don't have planes available, no
matter the format/modifier, we won't add the scanout tranche.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
---
 libweston/backend-drm/state-propose.c | 36 +++++++++++----------------
 1 file changed, 14 insertions(+), 22 deletions(-)

diff --git a/libweston/backend-drm/state-propose.c b/libweston/backend-drm/state-propose.c
index 1e62e2b..3e1a81b 100644
--- a/libweston/backend-drm/state-propose.c
+++ b/libweston/backend-drm/state-propose.c
@@ -413,6 +413,7 @@ drm_output_find_plane_for_view(struct drm_output_state *state,
 
 	bool view_matches_entire_output, scanout_has_view_assigned;
 	uint32_t possible_plane_mask = 0;
+	bool any_candidate_picked = false;
 
 	pnode->try_view_on_plane_failure_reasons = FAILURE_REASONS_NONE;
 
@@ -432,12 +433,10 @@ drm_output_find_plane_for_view(struct drm_output_state *state,
 	if (buffer->type == WESTON_BUFFER_SOLID) {
 		pnode->try_view_on_plane_failure_reasons |=
 			FAILURE_REASONS_FB_FORMAT_INCOMPATIBLE;
-		return NULL;
 	} else if (buffer->type == WESTON_BUFFER_SHM) {
 		if (!output->cursor_plane || device->cursors_are_broken) {
 			pnode->try_view_on_plane_failure_reasons |=
 				FAILURE_REASONS_FB_FORMAT_INCOMPATIBLE;
-			return NULL;
 		}
 
 		/* Even though this is a SHM buffer, pixel_format stores the
@@ -448,7 +447,6 @@ drm_output_find_plane_for_view(struct drm_output_state *state,
 				     "cursor view\n", ev);
 			pnode->try_view_on_plane_failure_reasons |=
 				FAILURE_REASONS_FB_FORMAT_INCOMPATIBLE;
-			return NULL;
 		}
 
 		if (buffer->width > device->cursor_width ||
@@ -458,10 +456,10 @@ drm_output_find_plane_for_view(struct drm_output_state *state,
 				     ev, buffer->width, buffer->height);
 			pnode->try_view_on_plane_failure_reasons |=
 				FAILURE_REASONS_FB_FORMAT_INCOMPATIBLE;
-			return NULL;
 		}
 
-		possible_plane_mask = (1 << output->cursor_plane->plane_idx);
+		if (pnode->try_view_on_plane_failure_reasons == FAILURE_REASONS_NONE)
+			possible_plane_mask = (1 << output->cursor_plane->plane_idx);
 	} else {
 		if (mode == DRM_OUTPUT_PROPOSE_STATE_RENDERER_ONLY) {
 			drm_debug(b, "\t\t\t\t[view] not assigning view %p "
@@ -477,20 +475,16 @@ drm_output_find_plane_for_view(struct drm_output_state *state,
 				possible_plane_mask |= 1 << plane->plane_idx;
 		}
 
-		if (!possible_plane_mask) {
+		if (!possible_plane_mask)
 			pnode->try_view_on_plane_failure_reasons |=
 				FAILURE_REASONS_INCOMPATIBLE_TRANSFORM;
-			return NULL;
-		}
 
 		fb = drm_fb_get_from_paint_node(state, pnode);
-		if (!fb) {
+		if (fb)
+			possible_plane_mask &= fb->plane_mask;
+		else
 			drm_debug(b, "\t\t\t[view] couldn't get FB for view: 0x%lx\n",
-				  (unsigned long) pnode->try_view_on_plane_failure_reasons);
-			return NULL;
-		}
-
-		possible_plane_mask &= fb->plane_mask;
+				     (unsigned long) pnode->try_view_on_plane_failure_reasons);
 	}
 
 	view_matches_entire_output =
@@ -521,7 +515,6 @@ drm_output_find_plane_for_view(struct drm_output_state *state,
 			assert(plane == output->cursor_plane);
 			break;
 		case WDRM_PLANE_TYPE_PRIMARY:
-			assert(fb);
 			if (plane != output->scanout_plane)
 				continue;
 			if (mode != DRM_OUTPUT_PROPOSE_STATE_PLANES_ONLY)
@@ -530,7 +523,6 @@ drm_output_find_plane_for_view(struct drm_output_state *state,
 				continue;
 			break;
 		case WDRM_PLANE_TYPE_OVERLAY:
-			assert(fb);
 			assert(mode != DRM_OUTPUT_PROPOSE_STATE_RENDERER_ONLY);
 			/* if the view covers the whole output, put it in the
 			 * scanout plane, not overlay */
@@ -613,6 +605,7 @@ drm_output_find_plane_for_view(struct drm_output_state *state,
 		else
 			zpos = MIN(current_lowest_zpos - 1, plane->zpos_max);
 
+		any_candidate_picked = true;
 		drm_debug(b, "\t\t\t\t[plane] plane %d picked "
 			     "from candidate list, type: %s\n",
 			     plane->plane_id, p_name);
@@ -620,9 +613,10 @@ drm_output_find_plane_for_view(struct drm_output_state *state,
 		if (plane->type == WDRM_PLANE_TYPE_CURSOR) {
 			ps = drm_output_prepare_cursor_paint_node(state, pnode, zpos);
 		} else {
-			ps = drm_output_try_paint_node_on_plane(plane, state,
-								pnode, mode,
-								fb, zpos);
+			if (fb)
+				ps = drm_output_try_paint_node_on_plane(plane, state,
+									pnode, mode,
+									fb, zpos);
 		}
 
 		if (ps) {
@@ -641,11 +635,9 @@ drm_output_find_plane_for_view(struct drm_output_state *state,
 			FAILURE_REASONS_PLANES_REJECTED;
 	}
 
-	if (!ps &&
-	    pnode->try_view_on_plane_failure_reasons == FAILURE_REASONS_NONE) {
+	if (!any_candidate_picked)
 		pnode->try_view_on_plane_failure_reasons |=
 			FAILURE_REASONS_NO_PLANES_AVAILABLE;
-	}
 
 	/* if we have a plane state, it has its own ref to the fb; if not then
 	 * we drop ours here */
